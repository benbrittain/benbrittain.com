<!DOCTYPE html>
<html lang="en"> 
<head>
    <title>Ben Brittain</title>
    <link rel="stylesheet" href="./css/default.css" type="text/css" media="screen"></link>
</head>
<body>
    <div id="nav">
        <ul>
            <li><h1>Ben Brittain</h1></li>

            <li> <a href="./index.html"> Blog </a></li>
            <li> <a href="./about.html"> About </a></li>
            <li> <a href="https://twitter.com/#!/Brittain_Ben"> Twitter </a></li>
            <li> <a href="https://github.com/cavedweller"> GitHub </a></li>
            <li> <a href="https://www.facebook.com/ben.brittain0"> FaceBook </a></li>
            <li> <a href="http://www.linkedin.com/in/bbrittain/"> LinkedIn</a></li>
            <li> <a href="mailto:ben@benbrittain.com">Email Me</a> </li>
        </ul>
    </div>

    <div id="content">
        <div id="main">
            <section class="posts">
  <section class="post">
    <div id="posttitle"><a href="./posts/2012/9/piet-fizzbuzz.html">My Hacker School FizzBuzz Program</a></div>
    <div id="postdate">September 12, 2012</div>
    <div id="post">

    <p>
I just finished up rebuilding my personal site using <a href="https://github.com/jaspervdj/hakyll">hakyll</a> (a static site generator library for haskell). As my inaugural blog post, I’m publishing a little blurb about one of my favorite programs I’ve written (or seen in general).
</p>
<p>
Back in April of 2012, I was up in Cleveland, Ohio visiting my family for a Passover seder. Late at night while everyone else was rightly asleep, I stumbled across an article on Hacker News about <a href="https://www.hackerschool.com">Hacker School</a>. It seemed like the ideal way to spend a summer… writing Open Source software with a bunch of awesome programers in NYC? count me in! (Hacker School was awesome BTW) The application was pretty sparse, it essentially asked for a link to your github, a couple of personal opinion questions, and for a short <a href="http://c2.com/cgi/wiki?FizzBuzzTest">fizzbuzz</a> program.
</p>
<p>
I was a little worried about standing out from the other applicants. I didn’t have much on my github &amp; who knows how to properly answer those personal opinion questions anyway?! I needed to shine with my fizzbuzz. I’ve always been amused by esoteric programming languages like <a href="http://en.wikipedia.org/wiki/Malbolge">Malbolge</a> and <a href="http://en.wikipedia.org/wiki/Brainfuck">BrainFuck</a>. After looking around, I decided I’d spend the 4 hour train ride back to Rochester (where I attend RIT) writting a program in piet. (Trains are awesome to write programs on… In fact, I’m pretty sure that trains are the most awesome form of travel out there).
</p>
<p>
<a href="http://www.dangermouse.net/esoteric/piet.html">Piet</a> is one of the more famous esoteric programming languages. It’s designed to look like the work of Piet Mondrian, a pioneer in abstract geometric art. Sure, the artistic purists out there will argue that Mondrian only used primary colors… oh well a little more complexity is nice. The actual source code is the image, usually a .PNG or .PPM file. Every block of color gets a numerical value based on the surface area of an uninterupted section of color. Operations are performed depending on the change in hue or lightness.
</p>
<img src="images/fizzbuzzLarge.png">
<p>
Here is the trace generated by the <a href="http://www.bertnase.de/npiet/">npiet</a> interpreter. If you are interested in writing a piet program, I’d highly advise using the npietedit tool. I really wish I had known about it when I wrote this program in gimp.
</p>
<img src="images/fizzbuzzTrace.png" width="864" height="608">


    
</div>
</section>
<section class="post">
    <div id="posttitle"><a href="./posts/2012/8/p2p-datachannel-satire.html">A Modest Proposal and Implementation of a Peer-To-Peer data channel using webRTC</a></div>
    <div id="postdate">August 21, 2012</div>
    <div id="post">

    <p>
WebRTC is a promising new standard for the web. The goal of WebRTC is to enable a whole host of applications such video chat, online games, and file sharing through a peer to peer connection. This is going to change the web as we know it. WebSockets, a protocol that allows fast communication between a browser and server, has resulted in many cool apps &amp; websites. However, client-server communication has always been available, alebiet in much less sophisticated ways. WebRTC is going to be comletely new. A native way to communicate peer-to-peer between a large (or small) number of peers without any plugins is going to make web apps even more like native applications.
</p>
<p>
For the last couple of weeks, <a href="http://dennis.is">Dennis Martensson</a> and I have been working on a library that aims to do for WebRTC what Socket.io did for WebSockets. Honestly, WebRTC is a pretty dense and complex protocol. There is a lot of stuff that the average developer really doesn’t want to deal with when attempting to implement a peer-to-peer connection. You need to know what STUN servers are, how to send ICE candidates, ROAP vs JSEP, etc… etc… The goal of our webRTC.io library is to simplify what you need for a basic peer-to-peer web app. This has been great fun, and we’ve gotten some good feedback from developers. However, the WebRTC specification is still missing the coolest part… <b> the data channel </b>.
</p>
<p>
The data channol is the most awesome part of the webRTC specification, and the main developers don’t even have a deadline for when it is supposed to have even basic functionality! Peer-to-peer anything! Dennis and I struck forth on our own. If we weren’t given a data channel, we were gonna make a data channel!
</p>
<p>
We tried injecting data into the sound track and the video track to no avail. At long last, we stumbled upon the solution. We could send data through the webcam. Sure, the rate of data transfer would be paltry in comparison to well… practically anything, but it mattered not! With a little effort, we used our webRTC.io library and built the first peer-to-peer data channel using webRTC!
</p>
<p>
we have a demo here: LINK HERE
</p>
<p>
The best part about our implementation of the p2p data channel is that it requires human interaction! No longer are you a slave to your machine; You control what gets sent! The general steps are as follows:
</p>
<ol style="list-style-type: decimal">
<li><p>
You generate a QR code which contains some JSON with a unique id, an Ack Response, and a body field. It also has some error checking built in.
</p></li>
<li><p>
You take a picture. I’m sure the final version of the protocol will recommend a smartphone for fast turn around time.
</p></li>
<li><p>
Hold the picture up to your webcam, In our demo application, a red line should appear when your side has read the data. this does not mean the other peer has gotten the data! The QR code library is extremelly finicky.
</p></li>
<li><p>
Continue holding the smartphone up to the webcam till the message you sent turns green. This could take a while depending who/what is on the other side of the connection. This means that you have received a new message which contains a succesful Acknowledgment.
</p></li>
<li><p>
repeat!
</p></li>
</ol>
<p>
Obviously this protocol needs a little work, but we have faith that the webRTC specification creators and implementors will take our suggestions into account.
</p>
<p>
addendum: Title reference: http://en.wikipedia.org/wiki/A_Modest_Proposal We love where webRTC is going, and we’d like to thank the developers of it. We just find it hilarious that we can send 30+fps video streams but not simple text.
</p>


    
</div>
</section>

</section>

<span><div id="linkolder"> </link></span><span> <div id="linknewer"></div></span>

        </div>
    </div>
</body>
</html>

